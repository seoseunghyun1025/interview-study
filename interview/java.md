​

📌 개발자 전공 면접에서 자바와 관련하여 자주 묻는 핵심 질문은 무엇인가?
자바가 왜 유명해졌는지, 자바 애플리케이션이 어떻게 실행되는지, 자바 메모리 구조, 가비지 컬렉션, 객체지향 프로그래밍의 특징, 그리고 추상 클래스와 인터페이스의 차이점입니다.









개발자 전공 면접에서 자바의 핵심 개념을 명쾌하게 설명하는 방법을 배울 수 있는 콘텐츠입니다. 자바가 유명해진 이유부터 JVM 실행 과정, 자바 메모리 구조 5가지 영역, 그리고 면접 단골 질문인 객체지향 4대 특징과 추상 클래스/인터페이스의 차이까지, 복잡한 개념들을 면접관에게 효과적으로 전달하는 실용적인 답변 스크립트를 제공합니다. 이 내용을 숙지하면 자바 기초 지식을 탄탄하게 다지고 면접에서 자신감을 얻을 수 있습니다.



1. 자바 소개 및 자바의 유명세 배경


1.1. 자바 학습 순서 결정
captureSource
자바 학습 시작: 장구 강사가 자바 학습을 시작함을 알림 

디자인 패턴 학습 계획 변경: 원래 디자인 패턴을 먼저 하려 했으나, 객체지향 개념이 많이 포함되어 있어 자바를 먼저 진행하는 것이 좋다고 판단하여 디자인 패턴 학습을 뒤로 미룸 



1.2. 자바가 유명해진 이유
captureSource
기존 프로그램 환경의 문제점: 자바 등장 이전에는 운영체제(OS) 위에 프로그램이 설치되었으며, OS(예: Mac OS, Windows)가 다르면 같은 언어로 작성된 코드라도 OS에 맞춰 다르게 코드를 작성해야 했음 

개발의 번거로움: 동일한 프로그램을 구현하기 위해 각 운영체제별로 코드를 따로 작성해야 하는 번거로움이 존재했음 

자바의 해결책: 자바는 운영체제 위에 미리 공통적으로 호환될 수 있는 부분을 짜놓았으며, 개발자는 그 위에 코드를 작성하면 되게 함 

결과: 개발자들이 운영체제별로 다르게 코드를 짤 필요가 없어지면서 자바가 매우 유명해지게 됨 



2. JVM과 자바 애플리케이션 실행 과정


2.1. JVM(Java Virtual Machine)의 역할
captureSource
JVM의 정의: 운영체제 바로 위에서 우리가 작성한 소스 코드를 돌릴 수 있게 해주는 역할을 하는 것이 JVM(Java Virtual Machine)임 

소스 코드 변환: 소스 코드를 컴파일하여 JVM 위에서 돌아가게 만듦 



2.2. 자바 애플리케이션 실행 단계
captureSource
소스 코드 작성 및 저장: 자바 소스 코드를 작성하고 저장함 

컴파일: 소스 코드를 컴파일하면 .class 파일로 저장됨 

바이트 코드: .class 파일로 저장되는 것은 바이트 코드이며, 이는 JVM에서 실행되는 하나의 2진 예임 (단순히 0과 1로 이루어진 것이 아님) 



2.3. JVM 내부 동작 과정
captureSource
클래스 로더(Class Loader): JVM 내부에서 클래스 로더가 바이트 코드를 불러와 런타임 데이터 영역이라고 불리는 자바 메모리에 로드함 

실행 엔진(Execution Engine): 로드된 바이트 코드를 실행 엔진에서 실행함 



2.4. 면접 답변 요약: 자바 실행 방법
captureSource
1단계 (컴파일): 컴파일러가 자바 소스를 바이트 코드로 변환함 

2단계 (로드): 클래스 로더가 바이트 코드를 런타임 데이터로 로드함 

3단계 (실행): 실행 엔진에 의해 던져진 바이트 코드가 실행됨 



3. 자바 메모리 구조 5가지 영역


3.1. JVM 메모리 영역의 구분
captureSource
운영체제 메모리와의 차이: 기존 운영체제에서 보던 코드, 데이터, 힙, 스택 영역 구분과 달리, JVM이 운영체제 메모리에 올라가면서 JVM 영역이 나누어지는 것임 

자바 메모리의 5가지 영역: 자바 메모리는 크게 5가지 영역으로 나뉨 

스레드별 영역: PC 레지스터, 스택 메모리, 힙 메모리는 스레드 별로 구성됨 

스레드 공통 영역: 스레드 공통으로 사용되는 영역이 존재함 



3.2. 스레드별 메모리 영역 상세 설명
captureSource
PC 레지스터: 현재 수행 중인 명령어를 가지고 있으며, JVM 명령어 2바이트 코드에서 가져온 명령어들이 저장됨 

스택 영역 (Stack Memory): 기존 운영체제에서와 같이 함수에 대한 정보가 들어감 

메소드의 매개 변수, 지역 변수, 리턴 정보 등이 저장됨 

네이티브 메소드 스택 (Native Method Stack): 자바 코드가 아닌, 자바 외 다른 언어(예: C, C++)로 작성된 코드를 실행시키기 위해 사용되는 영역임 (예: System.out.println 실행 시) 



3.3. 스레드 공통 메모리 영역 상세 설명
captureSource
힙 영역 (Heap Memory): 사용자가 사용하면서 생긴 데이터가 저장되는 공간이며, 데이터가 동적으로 할당되는 곳임 (운영체제 메모리 구조와 유사) 

메소드 영역 (Method Area): 클래스별로 공유되는 영역으로, 전역 변수, 정적 변수, 메소드 정보 등이 저장됨 (데이터가 정적으로 할당됨) 

총 5가지 영역: 위와 같이 자바는 5개의 메모리 영역으로 나누어짐 



3.4. 면접 답변 요약: 자바 메모리 구조
captureSource
영역 구분: 자바 메모리 구조는 크게 5가지이며, 스레드마다 PC 레지스터, 스레드 스택, 네이티브 메소드 스택을 가짐 

공통 영역: 스레드 공통으로는 힙과 메소드 영역이 있음 

PC 레지스터: 현재 수행 중인 명령의 주소가 들어감 

스택: 호출된 메소드의 매개변수, 지역변수, 리턴 값 및 연산 시 일시적으로 사용되는 정보들을 제공함 

네이티브 메소드 스택: 자바 외 언어(C, C++)를 수행하기 위한 공간임 

메소드 영역: 클래스별로 공유되며 상수 풀, 정적 변수, 메소드 정보가 저장됨 

힙 영역: 런타임 중에 생성되는 객체들이 동적으로 할당되는 곳임 



4. 가비지 컬렉션 (Garbage Collection, GC)


4.1. 메모리 관리의 필요성
captureSource
GC의 역할: 가비지 컬렉션은 JVM에서 메모리를 관리해주는 모듈임 

과거의 메모리 관리: 예전에는 개발자가 코드가 실행될 때 메모리에 계속 저장되는 데이터 중 쓰이지 않는 것들을 delete, reset 같은 방식으로 직접 해제하는 작업을 했었음 

자바의 자동 관리: 자바에서는 JVM이 이 작업을 자동으로 수행하며, 이것이 가비지 컬렉션임 



4.2. GC 작동 원리
captureSource
메모리 부족 시 중단: 소스 코드가 실행되다가 메모리가 꽉 차면 잠시 멈춤 (Stop The World) 

참조 확인: 멈춘 후, 메모리에 있는 객체들이 어디에서 참조되고 있는지 확인함 

객체 제거: 참조되고 있지 않은 객체들은 메모리에서 지워버림으로써 빈 공간을 생성함 

Stop The World: 메모리가 꽉 찼을 때 멈춰서 참조되지 않는 객체를 찾는 과정을 Stop The World라고 함 



4.3. 면접 답변 요약: GC란?
captureSource
정의: GC는 JVM에서 메모리를 관리하는 모듈이며, 힙 메모리를 재활용하기 위해 더 이상 참조되지 않는 객체들을 메모리에서 제거하는 작업임 

장점: 개발자가 직접 메모리를 정리하지 않아도 되어 개발 효율성이 향상됨 

단점: 참조되지 않는 객체를 찾는 과정(Stop The World)에서 스레드가 잠깐 중단되어 성능이 저하될 수 있음 



5. 객체 지향 프로그래밍 (OOP) 특징


5.1. 객체 지향 프로그래밍의 개념 이해
captureSource
개념의 어려움: 객체 지향 프로그래밍(OOP) 개념은 이해하기 어려우며, 한 번에 설명하기 힘든 개념임 

면접 시 접근: 면접관은 이미 OOP를 알고 있으므로, 용어를 완전히 설명하기보다 자신이 최선으로 설명할 수 있는 방식으로 설명하면 면접관이 이해할 수 있음 

현실 세계의 모델링: OOP는 현실 세계의 사물(키보드, 마우스 등)을 객체로 만들고, 그 객체가 필요한 특징(필드, 메소드)을 뽑아내어 프로그램을 돌리는 방식임 



5.2. 객체 지향 프로그래밍의 4대 특징
객체 지향 프로그래밍은 추상성, 캡슐화, 상속성, 다양성의 4가지 특징을 가짐 



5.2.1. 추상성 (Abstraction)
captureSource
정의: 공통적인 특징을 뽑아 하나의 개념으로 만드는 것임 

예시: '물'과 '음료'가 있을 때, 둘의 공통점인 '마시는 것'이라는 하나의 개념을 뽑아내는 것이 추상화임 



5.2.2. 캡슐화 (Encapsulation)
captureSource
정의: 각각의 객체 내부의 정보를 숨기고, 공개된 정보만 외부에 노출하여 객체들이 잘 연결되도록 하는 것임 

목적: 하나의 캡슐처럼 만드는 것이며, 외부와 연결이 많이 되는 것은 좋지 않음 (결합도가 높으면 안 됨) 

결합도: 외부 의존도가 높으면(결합도가 높으면) 코드를 수정하거나 재사용하기 어려워지므로, 외부와 많이 결합하지 않는 것이 좋음 

요약: 높은 내부 은닉도를 가지고 낮은 외부 결합도를 갖도록 하는 것이 캡슐화임 



5.2.3. 상속성 (Inheritance)
captureSource
문제 상황: 클래스 A가 1번과 2번 기능을 수행하고, 클래스 B가 A와 기능이 비슷하지만 1번, 2번 수행 후 3번을 추가로 수행해야 하는 경우 

중복 작성의 문제: 만약 1번과 2번 기능이 100개, 1000개라면 모두 다시 작성해야 하는 문제와, A의 기능이 수정되었을 때 B에서도 모두 수정해야 하는 문제, 실수로 수정하지 않아 버그가 발생하는 문제가 발생함 

상속의 해결: 상속을 통해 클래스 A의 객체를 그대로 재사용하여 B 안에 A를 포함시켜 중복 작성을 피하고 기능을 재사용할 수 있게 함 



5.2.4. 다양성 (Polymorphism)
captureSource
상황 설정: 데이터를 담는 리스트가 있고, 처음에 문자를 담는 push 메소드를 사용하다가 숫자를 담으려고 할 때 문제가 발생함 

문제: 이미 같은 이름(push)의 메소드가 존재하기 때문에, 숫자를 담으려면 push_숫자와 같이 이름을 다르게 정의해야 함 

다형성의 역할: 요청이 왔을 때, 그 안에 들어간 데이터 타입에 따라서 다른 방식으로 동작하도록 하는 것이 다형성임 

문자, 숫자, 불리언 등 다른 데이터 타입을 넣을 때 각각 메소드를 다르게 정의하는 작업을 수행함 



5.3. 면접 답변 요약: 객체 지향 프로그래밍
captureSource
OOP 정의: 현실 세계의 사물 같은 객체를 만들고, 그 객체가 필요한 특징을 뽑아서 프로그래밍하는 것임 

특징: 총 4가지 특징이 있으며, 추상화, 캡슐화, 상속, 다양성임 

다음 단계: 추상화, 캡슐화, 다양성을 설명한 후, 추상 클래스와 인터페이스로 넘어감 



6. 추상 클래스(Abstract Class)와 인터페이스(Interface)의 차이


6.1. 추상 클래스와 인터페이스의 정의 및 변화
captureSource
중요성: 추상 클래스와 인터페이스는 자바에서 중요하며 자주 물어보는 개념임 

추상 클래스: 내부의 추상 메소드가 하나 이상 포함된 설계적인 시초임 

인터페이스: 모든 메소드가 추상 메소드로 정의됨 

Java 8 이후 변화: Java 8부터 인터페이스에서도 메소드 정의가 가능해져서 두 개념의 경계가 모호해지고 있음 

핵심: 두 개념의 차이(본질)를 이해하는 것이 중요함 



6.2. 추상 클래스와 인터페이스의 목적 이해
captureSource
추상 클래스의 목적: 상속을 위한 것임 

부모 클래스에서 자식 클래스로 상속받아 재사용성을 위해 사용됨 

인터페이스의 목적: 도장 찍기(보장)를 위한 것임 

인터페이스를 구현하는 객체들은 모두 같은 이름의 메소드를 구현해야 하며, 이는 같은 동작을 할 수 있다는 것을 보장하기 위해 사용됨 

요약: 추상 클래스는 기능을 재사용하고 확장하는 것이 목적이며, 인터페이스는 객체들이 같은 동작을 하는 것을 보장하는 것이 목적임 



6.3. 면접 답변 요약: 차이점
captureSource
정의적 차이: 추상 클래스는 abstract 키워드를 가지며 추상 메소드를 하나 이상 포함해야 하고, 인터페이스는 인터페이스 지시자로 모든 메소드가 추상으로 정의됨 

목적의 차이:

추상 클래스: 상속받아 기능을 재활용하고 확장하는 데 목적이 있음 

인터페이스: 객체들이 같은 동작을 하는 것을 보장하는 데 목적이 있음 



7. 마무리 및 향후 학습 방향
captureSource
자바 학습 소감: 자바, 특히 객체 지향 개념이 어려울 수 있음을 언급함 

객체 지향 학습의 중요성: 객체 지향은 100m 달리기와 같으므로 계속 공부해야 하며, 이를 알아야 이후 디자인 패턴 등 다른 학습이 쉬워짐 

종료: 강의를 마무리함 

